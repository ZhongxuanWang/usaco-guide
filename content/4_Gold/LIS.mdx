---
id: lis
title: '(Optional) Longest Increasing Subsequence'
author: Michael Cao, Benjamin Qi, Andi Qu, Andrew Wang, Dong Liu, Siyong Huang
prerequisites:
  - intro-dp
description: Finding and using the longest increasing subsequence of an array.
frequency: 1
---

<!-- ### Longest Increasing Subsequence -->

<!-- Some of the problems in this section don't initially look like Longest Increasing Subsequence, but it ends up being the solution. <Asterisk> This can happen a lot, which is why it's a good idea to not focus on one topic unless you have a full solution.</Asterisk> -->

<Resources>

<Resource
	source="cp-algo"
	title="Longest Increasing Subsequence"
	url="https://cp-algorithms.com/sequences/longest_increasing_subsequence.html"
	starred
>
	A comprehensive guide (covers almost everything here)
</Resource>

</Resources>

<FocusProblem problem="sam" />

## Tutorial

In this tutorial, let $A$ be the array we want to find the LIS for.

### Slow Solution

**Time Complexity**: $\mathcal O(N^2)$

<Resources>
	<Resource source="CPH" title="7.2 - LIS">
		slow solution
	</Resource>
</Resources>

Let $dp[i]$ be the length of the longest increasing subsequence that ends on
$A[i]$. We can then naively compute $dp$ (and thus the LIS) in
$\mathcal{O}(N^2)$ time:

<LanguageSection>

<CPPSection>

```cpp
int find_lis(vector<int> a) {
	int n = a.size(), lis = 0;
	vector<int> dp(n, 1);
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < i; j++)
			if (a[j] < a[i])
				dp[i] = max(dp[i], dp[j] + 1);
		lis = max(lis, dp[i]);
	}
	return lis;
}
```

</CPPSection>

<JavaSection>

```java

public static int find_lis(int[] a) {
	int n = a.length, lis = 0;
	int[] dp = new int[n]; Arrays.fill(dp, 1);
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < i; j++)
			if (a[j] < a[i])
				dp[i] = Math.max(dp[i], dp[j] + 1);
		lis = Math.max(lis, dp[i]);
	}
	return lis;
}

```

</JavaSection>

</LanguageSection>

We can do much better than this though!

### Fast Solution

**Time Complexity**: $\mathcal O(N \log N)$

Let $L_i$ be an array where $L_i[j]$ is the smallest element from the first $i$
elements of $A$ with an increasing sequence of length $j$ ending on it (or
$\infty$ if there is no such element).

**Lemma 1:** $L_i$ forms a non-decreasing sequence.

**Proof:** Assume for a contradiction that for some $j$, we have
$L_i[j] > L_i[j + 1]$. However, this is impossible because an increasing
sequence of length $j + 1$ ending on some element implies that there is also an
increasing sequence of length $j$ ending on that same sequence.

**Lemma 2:** The length of the LIS ending on $A[i + 1]$ is equal to the least
index $j$ such that $L_i[j] \geq A[i + 1]$.

**Proof:** Firstly, since $A[i + 1] > L_i[j - 1]$, there is an increasing
sequence of length $j$ ending on $A[i + 1]$. By Lemma 1, $L_i$ is
non-decreasing, so $L_i[k] \geq A[i + 1]$ for all $k \geq j$. This means that
the length of the LIS is $j$.

**Lemma 3:** Exactly 1 element differs between $L_i$ and $L_{i + 1}$.

**Proof:** Obviously, we need to set $L_{i + 1}[j]$ to be $A[i + 1]$ since
$L_i[j] \geq A[i + 1]$. We don't update anything else though, since
$A[i + 1] > L_i[k]$ for all $k < j$ and there are no increasing sequences ending
on $A[i + 1]$ of length greater than $j$.

To find and update the described $j$ in $\mathcal{O}(\log N)$ time, we can use a
`std::vector` and `std::lower_bound`. Alternatively, we can use a `std::set`
(demonstrated in the solution for PCB).

<LanguageSection>

<CPPSection>

```cpp
int find_lis(vector<int> a) {
	vector<int> dp;
	for (int i : a) {
		int pos = lower_bound(dp.begin(), dp.end(), i) - dp.begin();
		if (pos == dp.size()) dp.push_back(i);
		else dp[pos] = i;
	}
	return dp.size();
}
```

</CPPSection>

<JavaSection>

```java
public static int find_lis(int[] a) {
	ArrayList<Integer> dp = new ArrayList<Integer>();
	for (int i : a) {
		int pos = Collections.binarySearch(dp, i);
		if(pos < 0) pos = Math.abs(pos + 1);
		if (pos == dp.size()) dp.add(i);
		else dp.set(pos, i);
	}
	return dp.size();
}
```

</JavaSection>

</LanguageSection>

## Example - PCB

<FocusProblem problem="nonIntersect" />

This problem asks us to find the minimum number of disjoint sets of
non-intersecting segments. This seems quite intimidating, so let's break it up
into two parts:

- Finding a set of non-intersecting segments
- Minimizing the number of these sets

### Application 1 - Non-intersecting Segments

First, what can we say about two segments $(l_1, r_1)$ and $(l_2, r_2)$ if they
intersect (assuming $l_1 < l_2$)?

Since these segments are straight, notice how $l_1 < l_2 \implies r_1 > r_2$.

This means that a set of non-intersecting segments satisfies
$l_i < l_j \implies r_i < r_j$ for all pairs $(i, j)$!

Let $A$ be an array where $A[i] = x$ means that the segment with its right
endpoint at position $i$ has its left endpoint at position $x$.

If we were asked to find the maximum size of a set of non-intersecting segments,
the answer would be the LIS of $A$!

### Application 2 - Minimum Number of Increasing Sequences

Continuing from application 1, we now want to find the minimum number of
increasing subsequences required to cover $A$.

Luckily for us, there's a simple (though not so obvious) solution to this.

**Lemma (Easy):** The minimum number of increasing subsequences required to
cover $A$ is at least the size of longest non-increasing subsequence of $A$.

_Proof:_ No two elements of any non-increasing subsequence can be part of the
same increasing subsequence.

**Claim:** The minimum number of increasing subsequences required to cover $A$
is equal to the size of longest non-increasing subsequence of $A$!

**Wrong Proof 1:** See
[cp-algo](https://cp-algorithms.com/sequences/longest_increasing_subsequence.html#toc-tgt-13)
(note that this link describes partitioning $A$ into non-increasing subsequences
rather than increasing subsequences). However, it's not correct because the
process of unhooking and reattaching might never terminate. For example,
consider partitioning $A=(3,1,2)$ into the non-increasing subsequences
$s_1=(3,1)$ and $s_2=(2)$. Then $3$ will be moved from the front of $s_1$ to the
front of $s_2$ on the first step, back to $s_1$ on the second step, and so on.

**Wrong Proof 2:**
[This](https://math.stackexchange.com/questions/3739994/find-minimum-number-of-increasing-subsequences)
is essentially the same as the above.

**Motivation:** Consider the obvious greedy strategy to construct the collection
of increasing subsequences (essentially
[patience sorting](https://en.wikipedia.org/wiki/Patience_sorting)). For each
element $x$ of $A$ from left to right, add it to the increasing subsequence with
last element less than $x$ such that the value of this last element is
maximized. If no such increasing subsequence currently exists, then start a new
increasing subsequence with $x$.

This algorithm performs exactly the same steps as the algorithm to compute the
length of the longest non-increasing subsequence, so it follows that they return
the same result.

**Proof:** Let $f_i$ denote the length of longest non-increasing subsequence
ending at $A_i$. Then the $A_i$'s satisfying $f_i=t$ for a fixed $t$ are an
increasing subsequence for each $t$. So we have covered $A$ with (size of
longest non-increasing subsequence) increasing subsequences, done.

Do you see why this is equivalent to the sketch?

**Alternative Proof:** This is just a special case of
[Dilworth's Theorem](https://en.wikipedia.org/wiki/Dilworth%27s_theorem). See
the inductive proof.

### Code

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int lis = 0;
pair<int, int> a[100000];
set<int> s;

int main() {
	iostream::sync_with_stdio(false);
	cin.tie(0);
	int n;
	cin >> n;
	for (int i = 0; i < n; i++) cin >> a[i].first >> a[i].second;
	sort(a, a + n, greater<pair<int, int>>());
	// finding the LIS of a reversed array = finding the LDS
	for (int i = 0; i < n; i++) {
		if (s.upper_bound(a[i].second) == s.end()) lis++;
		else s.erase(s.upper_bound(a[i].second));
		s.insert(a[i].second);
	}
	cout << lis;
}
```

</CPPSection>

<JavaSection>

```java
import java.io.*;
import java.util.*;

class PCB{
	public static void main(String[] args) throws IOException
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int n = Integer.parseInt(br.readLine());
		TreeMap<Integer, Integer> a = new TreeMap<Integer, Integer>(Collections.reverseOrder());
		for(int i = 0; i < n; i++){
			StringTokenizer st = new StringTokenizer(br.readLine());
			a.put(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken()));
		}
		//finding the LIS of a reversed array = finding the LDS
		int lis = 0;
		TreeSet<Integer> s = new TreeSet<Integer>();
		for(int k : a.keySet()){
			if(s.higher(a.get(k)) == null) lis++;
			else s.remove(s.higher(a.get(k)));
			s.add(a.get(k));
		}
		System.out.println(lis);
	}
}
```

</JavaSection>

</LanguageSection>

## Extension - LCS on Permutations

<FocusProblem problem="lisperm" />

Given two permutations of length $N$ ($1\le N \le 10^5$), find the longest
common subsequence.

### Example

#### Example Input

```
5
3 2 1 4 5
1 2 3 4 5
```

#### Example Output

```
3
```

### Slow Solution

**Time Complexity**: $\mathcal O(N^2)$

See [here](/gold/paths-grids#solution---longest-common-subsequence).

### Efficient Solution

**Time Complexity**: $\mathcal O(N\log N)$

In the $\mathcal O(N^2)$ solution, we increase the DP arrray only if
$a[i] = b[j]$, but since both arrays are permutations of length $N$, for each
$a[i]$, there must be only one matching element in $b$.

Let us create an array $pos$ where $pos[x]$ is the index of $x$ in $a$
($a[pos[x]] = x$). Then, we can create another array, $c$ where $c[i]$ stores
$pos[b[i]]$.

Notice that every increasing subsequence $x_{1 \dots k}$ in $c$ corresponds to a
common subsequence between $a$ and $b$. Increasing subsequence
$c[x_1], c[x_2], \dots c[x_k]$ corresponds to the the common subsequence
$b[x_1], b[x_2], \dots b[x_k]$, which is equivalent to
$a[c[x_1]], a[c[x_2]], \dots a[c[x_k]]$. Thus, the length of the longest common
subsequence between $a$ and $b$ is the longest increasing subsequence of $c$.

Finding a LIS takes $\mathcal O(N\log N)$, so the overall time complexity in
this algorithm is $\mathcal O(N\log N)$.

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 5;
int n, a[N], b[N], c[N], pos[N];
vector<int> lis;

int main() {
	cin.tie(0)->sync_with_stdio(0);

	cin >> n;
	for (int i = 1; i <= n; ++i) {
		cin >> a[i];
		// pos is the inverse of a
		pos[a[i]] = i;
	}
	for (int i = 1; i <= n; ++i) {
		cin >> b[i];
	}
	for (int i = 1; i <= n; ++i) {
		c[i] = pos[b[i]];
	}

	for (int i = 1; i <= n; ++i) {
		int p = lower_bound(begin(lis), end(lis), c[i]) - begin(lis);
		if (p == lis.size())
			lis.push_back(c[i]);
		else
			lis[p] = c[i];
	}
	cout << lis.size() << '\n';
}
```

</CPPSection>

</LanguageSection>

## Problems

<Problems problems="lis" />

<!-- <Resource source="CF" title="DP List" url="325">
 	misc probs, a lot of which you don't need to know at this level
</Resource> -->
